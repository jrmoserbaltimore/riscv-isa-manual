i% vim: ts=4 sw=4 et
\chapter{``Zvinx'' Standard Extension for Lightweight Vector Architecture, v0.0}
\label{sec:zvinx}

This chapter defines the ``Zvinx'' extension, which extends the ``RVI'' base
instruction set, the ``M'' extension, the ``A'' extension, and the floating
point ``F'', ``D'', and ``Q'' extensions via a vector mode controlled by a
new CSR.

\begin{commentary}
    The lightweight vector extension is intended to support data-parallel
    execution of existing arithmetic and floating-point instructions, with
    minimal implementation or instruction stream complexity.  Atomic vector
    operations are excluded:  both locking primitives and transactional
    memory better provide for large atomic operations, and atomic vector
    operations add significant implementation complexity.

    Superscalar implementations can issue multiple regular base instructions
    in parallel, denoting them as part of a single instruction, and
    reassemble the output at instruction retirement or at memory store with
    minimal added complexity.

    Lightweight vector instructions can be implemented with minimal additional
    delay by checking if an instruction or data output is part of a vector
    operation and executing normally if not, or otherwise adding latency and
    carrying out partitioning or reassembly over an extra clock cycle.

    The sll, srl, and sra operations can reuse a barrel shifter, in combination
    with bit masking, requiring extra hardware or an extra clock cycle.  A
    single 32-bit barrel shifter can carry out four 8-bit shifts.

    A 32-bit carry-select or parallel prefix adder-subtractor can simultaneously
    produce one 32-bit result, two 16-bit results, or four 8-bit results with
    minimal extra hardware.  Parallel prefix adders require fan-out to a duplicate
    final stage, with all sub-adders out of the critical path; variable-length
    carry-select adders must have splits on 8-bit boundaries.

    The and, or, and xor operations affect each bit in isolation and require no
    special hardware.  These, the shift operations, and the adder-subtractor
    operations may subdivide a single circuit within an ALU to execute on
    multiple data values of a word width narrower than XLEN.

    Each of these modifications requires only self-contained and minor behavioral
    changes and a few extra control bits.  Vector operations are easily tracked
    for completion across individual registers, minimizing the additional logic
    in detecting when a register has been fully written and allowing out-of-order
    instruction scheduling with little or in some implementations no logic changes.
\end{commentary}

\begin{figure*}[h!]
    {\footnotesize
        \begin{center}
            \begin{tabular}{U@{}cccc}
                \instbitrange{31}{7} &
                \instbit{6} &
                \instbit{5}{4} &
                \instbitrange{3}{0} \\
                \hline
                \multicolumn{1}{|c|}{\warl} &
                \multicolumn{1}{c|}{W} &
                \multicolumn{1}{c|}{M[1:0]} &
                \multicolumn{1}{c|}{Size[3:0] (\wlrl)} \\
                \hline
                27 & 1 & 2 & 4 \\
            \end{tabular}
        \end{center}
    }
    \vspace{-0.1in}
    \caption{Lightweight Vector Register ({\tt zvinxd}).}
    \label{misareg}
\end{figure*}

When vector behavior is enabled, instructions acting as vector instructions are said
to be vector instructions.

Vector instructions are instructions of the form {\em op x15, x15, x11}, loads of
the form {\em lw x15, 0(rs1)} or {\em lw x11, 0(rs1)}, and stores of the form
{\em sw x15, 0(rs1)} and {\em sw x11, 0(rs1)}.  x15 and x11 are termed the upper and
lower vector registers, respectively.

\begin{commentary}
    Instructions not of the vector form will act as normal in vector mode, even
    when using vector instructions.  This allows code to avoid switching in and
    out of vector mode continuously during complex vector-heavy subroutines.
\end{commentary}

Size indicates the vector width.  When Size is 0, vector behavior is disabled;
otherwise vector operations target the upper and lower vector banks according to Size.
Vector banks extend down to include the number of registers indicated by Size, with
Size = 4 indicating x15 through x12 as the upper bank and x11 through x8 as the lower
bank.  Implementations may support smaller Size settings and must read as the lower
of the last value written or the maximum Size supported.

\begin{commentary}

    Architectural limitations may limit vector operation size.  ASIC implementations
    may make trade-offs between cost and supported width.  Simulators may optimize
    for the host platform's vector register width.

    FPGA implementations often have limited block RAM port width and may waste
    resources on enough BRAM to supply the port width.  A 32KiB BRAM cache on 32Kib
    BRAM with 64-bit data port can supply a 64 byte read or write, or 8 registers;
    the 96-byte vector loads and stores to support W mode's 12-register Size
    requires 12 such BRAMs.  These figures double when implementing RV128.

    Software can read Size into a register and add it to an iterator to implicitly
    use the maximum Size.  This value also determines when the software must
    handle the tail end, and again the code required for a single hard-code value
    largely only needs an {\em addi} replaced with an {\em add} to use a dynamic
    value.

\end{commentary}

W indicates wide vector mode.  Implementations must set W to 0 on reset and only
enable wide vector mode when written.  Implementations not supporting wide vector
mode may hardwire W to 0.  In wide vector mode, x31 and x19 are the upper and
lower register vectors, and Size may be as high as 12.

\begin{commentary}
    Wide vector mode is unsupported on RVE, and RVE-only code is not required to
    account for wide vector mode.  Wide vector mode code should set and reset W
    before and after executing; RVE-only code may always write 0 to W as a
    guard against incorrect RVI wide vector code, but this does not guarantee
    correct operation of the incorect code, e.g. if it sets W in initialization
    and assumes W is never unset.

    Software supporting wide vector mode must check if W remains 0 after set
    and select between alternate code targeting the same registers.  Code can
    use two branch instructions, but two separate loops are preferable when
    looping to avoid performance loss on implementations without sufficient
    branch prediction and speculative execution.
\end{commentary}

Vector operations operate across the span of vector registers.  Vector loads and
stores read and write the full width of the vectors at once.  Loads and stores
must align to XLEN.

The most recent vector load indicates vector element width, without regard to the
target register bank or the prior load.  Store operations mismatched in data
width are invalid and raise an exception. {\em FIXME: what kind of exception?}
{\em FIXME:  element width exposed in CSR?}

\begin{commentary}
    We considered making all store operations valid or undefined, but rejected
    this in favor of enforcing correctness.  Vector loads already must be full
    XLEN loads to each register, and stores the same.
\end{commentary}

When ``M'' is non-zero, x7 acts as a vector mask:  operations only apply to vector
elements where x8[i] is 1.  When ``M'' is 01, vector operations do not apply to masked
vector elements, and the elements are unchanged in the register, read on load, and
written back on store; when ``M'' is 10, vector operations do not apply to masked
elements, and masked elements are zeroed on load and written back on store; when ``M''
is 11, vector operations do not apply to masked elements, loads do not overwrite masked
elements in the registers, and stores do not affect the memory contents targeted by
masked elements.

\begin{table}[htp]
    \begin{small}
        \begin{center}
            \begin{tabular}{cl}
                \hline
                \multicolumn{1}{|c|}{M Register} &
                \multicolumn{1}{c|}{Meaning} \\
                \hline
                \multicolumn{1}{|c|}{00} &
                \multicolumn{1}{c|}{No masking}\\
                \hline
                \multicolumn{1}{|c|}{01} &
                \multicolumn{1}{c|}{Load and store masked elements unchanged}\\
                \hline
                \multicolumn{1}{|c|}{10} &
                \multicolumn{1}{c|}{Load masked elements as zero}\\
                \hline
                \multicolumn{1}{|c|}{11} &
                \multicolumn{1}{c|}{Ignore:  loads and stores do not write masked elements to memory or register}\\
                \hline
            \end{tabular}
        \end{center}
    \end{small}
    \caption{Accrued exception flag encoding.}
    \label{bitdef}
\end{table}

Size cannot be greater than 8 when M is enabled.

\begin{commentary}
    Masking removes vector elements from the execution path, freeing up resources.
    Operations must never raise exceptions due to masked vector elements.
    Implementations must write the actual contents of unchanged and zero-masked
    vectors back to memory.

    Zeroing-masked elements allows zeroing multiple registers at once by loading an
    arbitrary address.  Implementations can avoid a cache miss by not issuing a read
    for masked elements.

    Ignored-masked elements are neither read from nor written to memory and do not
    alter the contents of registers on load.
\end{commentary}

Only non-immediate base instructions are valid vector instructions.  Immediate and
width-specific instructions raise an exception when called in the vector form.
{\em FIXME:  which?}

The same rules apply for the ``F'', ``D'', and ``Q'' floating-point extensions with
respect to ``x15'' and ``x11'' or ``x31'' and ``x19''.

\begin{commentary}
    Supporting immediate and width-specified instructions would complicate the
    lightweight vector operations implementation for no obvious benefit.  Extension
    instructions, notably {\em mulh}, are an exception.
\end{commentary}

\begin{commentary}
    Lightweight vector operations will extend to the M instructions by exposing
    an M flag in zvinxd.

    An F, D, H, and Q field will indicate support for floating point vector
    operations.  A future draft will describe this.  As with integer operations,
    only operations of the same format may be used after the immediate latest
    floating point vector load.

    Floating point vector configurations will have additional Size and M fields,
    termed FSize and FM.  An additional two-bit FX register, for Float Extend,
    defines the register format:  floating-point vectors can use the full
    register for smaller operations.  For example, if FX is set to 2'b11 when
    the Q extension is supported and Size to 12, FLW loads 48 single-precision
    floats across each of the 12 128-bit registers.  Operations naturlly using
    regisers larger or equal to FX are unaffected by its value.

    Implementations will not be required to support extended floating point
    vector operations.  An implementation supporting F, D, and Q vector
    operations may support setting FX to 01, using 64-bit registers and
    doubling the number of elements loaded for single-precision operations,
    while not supporting setting FX to 11 and using 128-bit registers.
    All smaller operations must be supported by the maximum FX supported.

    As with other fields, these are {\warl} and must be tested by software
    making use of them.  Software may multiply FSize by the effective increase
    gained through wider registers to determine the number number of
    operations per enstruciton, e.g. when FSize is 12 and FX is Q, vector
    operations will perform 48 single-precision floating point operations per
    instruction.

    Support for the extension providing the given register size is not
    strictly necessary, and an implementation may support only the F
    extension while allowing FX to be Q.  Specialized vector processors
    may opt to do this when the logic for D and Q extensions is unnecessary
    but the application strongly benefits from larger vector operations.

\end{commentary}

